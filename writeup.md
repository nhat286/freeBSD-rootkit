
Final Rootkit Writeup
Members of Group 99:

z5091650 Johnson Shi
z5110198 Deepanjan Chakrabraty
z5137455 Minh Thien Nhat Nguyen
z5087077 Ka Wing Ho

Rootkit

Our rootkit is a loadable kernel module that hijacks a preexisting syscall to perform privilege escalation if a specific set of arguments is passed in. If not, then the hijacked syscall would mimic the original syscall to minimise the possibility of detection. For our current implementation, the hijack victim syscall will be openat, which is syscall number 499.
sys/sysent.h provides a definition of sysent which is a pointer to the global sysent table of the machine, which is an array of struct sysents. Struct sysent contains a function pointer to the system call handler/function for a specific syscall number, and it also contains associated metadata for the system call such as number of arguments.
Upon loading the kernel module using kldload, our current implementation mallocs a memory region of size 256 bytes to store the hook function. It does so by copying the instruction bytes from our function hook to the malloc-ed address, stopping only when 256 bytes have been copied or when we hit a page boundary (because permissions may not be the same across pages). Then, it writes a relative jump instruction at 3 bytes after the old syscall address. The relative jump will jump from old_syscall_address+3 to the malloc-ed region of memory. The reason why we insert the inline jump hook 3 bytes after the beginning of the syscall is to minimize our chances of being detected (as some teams will check for the first opcode at the beginning of the syscall address and check whether that is an opcode that transfers execution, such as jmp or call instructions). The kernel module is then unloaded using kldunload as it has served its purpose which is to inject an inline hooking inside the syscall to jump to our own malicious function residing in the malloc-ed region of memory.
The general idea of our rootkit is that it will keep the function pointer of the system call entry to point to openat’s original syscall handler. The inline function hook will then transfer execution to our function hook. Our function hook will then reinvoke the old system call passing it the same set of arguments. If the return value of the original system call is not 0, then it is not safe for the function hook to check for the arguments of the syscall as they may not be mapped to function memory. If the original syscall returns 0 indicating successful execution, we will then check the path argument to see if the path prefix matches a password string. If it does match, we will set curthread’s ucred struct (which represents user credentials) to root. This escalates the currently running processes and future child processes to root. Our script will then pop a shell using the sh command.
Our function hook (which resides in the malloc-ed region of memory) has a small nop-sled at the beginning of the function. When the openat syscall is invoked, the old system call handler will be called. The first three instruction bytes would be executed (the first 3 instructions are part of the function prologue where the stack is set up). The relative jump would then be performed to jump to the nop-sled at the beginning of the function hook. Because we reached the function hook through the nop-sled and because we reached this function without having its function prologue being executed, we need to manually set up the function prologue (its stack). But as the first 3 instructions have been executed (which pushes the old base pointer and sets the new base pointer) we will set up the remaining instructions of the function prologue. Since we have overwritten bytes 3 to 7 of the old system call, we cannot use the call instruction to jump to the old system call otherwise the stack will be inconsistent which will cause a crash. The 5 bytes corresponding to the relative jump hook also overwrites some instructions relevant to setting up the stack of the old system call. These reasons prevent us from just using the call instruction to jump to the old system call.
We will get the program counter from within the inline function hook, store it into ecx and increment it so that ecx contains an address that points to the second nop-sled of the function hook (which resides down below). We manually push ecx as the return value of the old system call. We also push in the system call’s arguments. We then set up the first 8 bytes of the function prologue of old system call because we have partially overwritten them with a jump hook. We will then perform an absolute jump to old_syscall+8 by performing a push ret trick. This transfers execution to the old system call. The second nop-sled follows these instructions. We also use several compiler tricks to prevent certain regions of the code from being optimised out, and also to ensure that the compiler always associates the variable ret_val with eax.
When the old system call returns, it returns to the second nop-sled. Its return value will be placed inside eax which the compiler thinks is the variable ret_val. If the ret_val is 0, then we proceed with checking for the password prefix and escalating the current thread.

Changes made since the midpoint

Instead of simply redirecting the syscall function pointer, we now insert a jump hook to jump to our function hook at a malloc-ed region of memory. Also, instead of targeting the rmdir syscall, we now target the openat syscall which is used by the touch command. If `touch ‘*3f5b1’`, the current process and thread are escalated to root.
Our rootkit does not attempt any bonus challenges.

Detection

Our detect tarfile contains several statically linked binaries so that we minimize dependence of the rootkit detector on host userland binaries. The shebang of our detect script refers to a statically linked sh binary that we obtained from /rescue so that teams that have manipulated /bin/sh cannot defeat and prevent execution of our detect script. The detect script calls other scripts (one for kernel-side checking, one for hashsum checking of common userland binaries + the kernel file itself, and one for detecting userland inconsistencies with kldstat).
Kernel-side detection
The kernel-side detection depends on several kernel modules that check for the consistency. We use kernel modules because they are a convenient way to execute within the kernel. The modules are loaded using a statically linked version of kldload. The first kernel module checks the syscall function pointer entries of all syscalls within the sysent, and compares them with known values from a clean host. Since this VM will not have KASLR, and since the sysent is set up during boot time (boot sequence is the same for clean hosts), the known values from a clean host will always be the same for clean hosts. The second kernel module checks whether the first few instructions of the syscall handler functions are JMP or CALL instructions. We cannot conclusively check deeper instructions because x86 is a CISC ISA and the opcodes may appear within the function as either opcode instructions or instruction arguments. The third kernel module checks the consistency of the proc and thread data structures. This module checks whether each proc in the allproc list is in the pidhashtbl, each proc that exists in the pidhashtbl is in the allproc list, each thread in each proc exists in the tidhashtbl, nprocs is consistent with the number of elements in allproc list, zombproc list, and pidhashtbl, and for each proc, actual nthreads is consistent with the p_numthreads field of the proc.

Hashsum Check

Although fairly trivial, we also do some signature detection, by bringing a file with hashsums of common binaries as well as the kernel file to catch any teams who meddle in the userland. We use a statically linked md5 binary (and other helper binaries such as cat and echo) to calculate the hashsums and compare them with the hashsum values we obtained from a clean host.
The last detect script checks for inconsistencies of kldstat using a statically linked version of kldstat. It greps to check whether any other modules are loaded in memory, and whether there are more than two modules in the system. It also ensures that the kernel module itself is within the system.

Rootkit Detector Design Decisions
* we saw lots of other teams doing the bonus marks
* also some teams were relying very heavily on the book methods (some of them are not entirely hiding the rootkit)
* therefore we try to use out-of-the-book methods to catch sloppy teams
* we also do high-level behaviour and signature detection just to be well-rounded
* our detection doesn't focus very much on signature ie trojan'ed binaries searching for suspicious files simply because most teams are not doing userland rootkits, therefore we shifted our focus more on kernel-level detection
